
Bjarne Stroustrup

Arthus, Denmark
Cambridge University
Bell Labs, New Jersey

== http://www.stroustrup.com/videos.html

2007.2 C++0x: An Overview
2007.8 Evolving a language in and for the real world: C++ 1991-2006
2009.9 The Design of C++0x
2010.8.12 Why I Created C++
    What are the five most important luanguages that programmers should know ?

2012.9 A Concept Design for C++
2012.9 C++11 Style - A Touch of Class
2013.7 The Essence of C++ with examples in C++84, C++98, C++11, and C++14
2014.9 CppCon2014: Make Simple Tasks Simple!
2015.9 CppCon2015: Writing good C++14
2016 CppCon2016: The Evolution of C++ Past, Present, and Future
2016.10 TEDx CaohejingParkSalon: The Driving Force Behind C++
        漕河泾
2016.11 What C++ is and what it will become


== 2017 CppCon2017: Learning and Teaching Modern C++


== 2007.2 C++0x: An Overview


== 2007.8 Evolving a language in and for the real world: C++ 1991-2006


== 2009.9 The Design of C++0x

A draft for a revised ISO C++ standard, C++0x, has been produced.
The speaker will present the background of C++, its aims, the standards process
(with opinions), some of the guiding design principles (with tiny code examples),
and two case studies. The case studies are initialization (a general and uniform
syntax and semantics for initializers in all contexts) and concurrent support
facilities (memory model, threads, locks, futures). 


2010.8.12 Big Think Interview With Bjarne Stroustrup 
    Question: What inspired you to create C++?

    Bjarne Stroustrup: In the really old days, people had to write their code
directly to work on the hardware.  They wrote load and store instructions to get
stuff in and out of memory and they played about with bits and bytes and stuff. 
    You could do pretty good work with that, but it was very specialized.  Then
they figured out that you could build languages fit for humans for specific
areas.  Like they built FORTRAN for engineers and scientists and they built
COBALT for businessmen.  

    And then in the mid-'60s, a bunch of Norwegians, mostly Ole-Johan Dahl and
Kristen Nygaard thought why can’t you get a language that sort of is fit for
humans for all domains, not just linear algebra and business.  And they built
something called SIMULA.  And that’s where they introduced the class as the
thing you have in the program to represent a concept in your application world.
So if you are a mathematician, a matrix will become a class, if you are a
businessman, a personnel record might become a class, in telecommunications a
dial buffer might become a class—you can represent just about anything as a
class.  And they went a little bit further and represented relationships between
classes; any hierarchical relationship could be done as a bunch of classes.  So
you could say that a fire engine is a kind of a truck which is a kind of a car
which is a kind of a vehicle and organize things like that.  This became know as
object-oriented programming or also in some variance of it as data abstraction.   

    And my idea was very simple: to take the ideas from SIMULA for general
abstraction for the benefit of sort of humans representing things... so humans
could get it with low level stuff, which at that time was the best language for
that was C, which was done at Bell Labs by Dennis Ritchie.  And take those two
ideas and bring them together so that you could do high-level abstraction, but
efficiently enough and close enough to the hardware for really demanding
computing tasks.  And that is where I came in.  And so C++ has classes like
SIMULA but they run as fast as C code, so the combination becomes very useful. 

    Question: What makes C++ such a widely used language?

    Bjarne Stroustrup: If I have to characterize C++’s strength, it comes from the ability to have abstractions and have them so efficient that you can afford it in infrastructure.  And you can access hardware directly as you often have to do with operating systems with real time control, little things like cell phones, and so the combination is something that is good for infrastructure in general.  

Another aspect that’s necessary for infrastructure is stability.  When you build an infrastructure it could be sort of the lowest level of IBM mainframes talking to the hardware for the higher level of software, which is a place they use C++.  Or a fuel injector for a large marine diesel engine or a browser, it has to be stable for a decade or so because you can’t afford to fiddle with the stuff all the time.  You can’t afford to rewrite it, I mean taking one of those ships into harbor costs a lot of money.  And so you need a language that’s not just good at what it’s doing, you have to be able to rely on it being available for decades on a variety of different hardware and to be used by programmers over a decade or two at least.  C++ is now about three decades old.  And if that’s not the case, you have to rewrite your code all the time.  And that happens primarily with experimental languages and with proprietary commercial languages that change to finish... to meet fads.  

C++’s problem is the complexity partly, because we haven’t been able to clean it up.  There’s still code written in the '80s that are running and people don’t like their running codes to break.  It could cost them millions or more. 



    Question: What is the future of programming?

Bjarne Stroustrup: There’ll be a unified language, but I’m not talking about programming language.  I’m talking more about a unified design style, a unified set of guidelines for how to combine the techniques.  I certainly hope that there will not be just one programming language.  I don’t think that’s at all likely and I would be sad because we would have lost a lot when we don’t have this tension between the languages that allows us to make progress.  I mean, the middle ages may have been very comfortable, but I don’t think I would have wanted to live there.  I like the diversity of ideas and the early ideas rubbing up against each other.  That’s how we make progress.  





    Question: Are you a proponent of open source software?

Bjarne Stroustrup: I am generally in favor of open source software with very few, if any, restrictions.  So I like the BSD Licenses.  I am not anti-commercial.  I would not put something into my license that would be a virus against commercial use.  

On the other hand, I don’t think that all software can or should be open because there’s a lot of sort of boring stuff that requires a high level of expertise to deal with.  I mentioned sort of the firmware layers and hardware and such. There’s very few people that really understand it.  You don’t get it maintained by a couple of volunteers because you need maybe five, 10 years experience in a particular field to do anything constructive and there’s lots and lots of software that’s not glamorous, that’s not interesting where you’ll simply not get the strength of the open source movement where you have lots of people, lots of contributions both individuals and organizations.  But there’s a lot of software where people just aren't interested.  And for that you need something else to keep it going and that’s usually the dollars that people get for doing the hard, sometimes boring, and sometimes advanced stuff.  So I think we always will have open source software and some closed.

I guess I should add that C++ is used to both anyways, so.  I don’t have a... I don’t have a horse in that race, so I have both.

== Question: What are the five most important languages that programmers should know?

Bjarne Stroustrup: First of all, nobody should call themselves a
professional if they only knew one language.  And five is a good number for
languages to know reasonably well. 

    And then you'll know a bunch, just because
you're interested because you've read about them because you've wrote a couple
of little programs like [...].  But five isn't a bad number.  Some of them book
between three and seven.

Let's see, well my list is going to be sort of uninteresting because it's
going to be the list of languages that are best known and useful, I'm afraid.
Let's see,
    C++, of course;  
    Java; 
    maybe Python for mainline work.
    And if you know those, you can’t help know sort of a little bit about Ruby and JavaScript, you can't  help knowing C because that's what fills out the domain, 
    and of course C-Sharp.

    But again, these languages create a cluster so that if you knew either five
of the ones that I said, you would actually know the others.  I haven't cheated
with the numbers.  I rounded out a design space.

    It would be nice beyond that to know something quite weird outside.
It just to have an experience, pick one of the functional languages, for instance,
that's good to keep your head spinning a bit when it needs to. 

    I don't have any favorites in that field. There’s enough of them.  And, I don't know, if
you're interested in high-performance numerical computation, you have to look at
one of the languages there, but for most people that's just esoteric (深奥的).

== Question: What are the most interesting trends in technology?

    Bjarrne Stroustrup: Many things are interesting these days.  The interesting thing for me is the computers they have inside it.  And so when you see things, cars driving down there, planes flying and such, you can see them as a distributed computing system with wings or distributed computing system with wheels.  

I was over in Germany earlier in the year to speak to the German automotive software conference.  And I don’t know much about programming cars, but I got an invitation to go down and see how they programmed the BMWs, which is C++, so that'll be interesting.  Not that the other weren’t, but those are cool cars.  And I’ve worked with some people up at Lockheed Martin where they build the F-35s, the new fighter planes, which is C++ also.  So I get some insight in how things are used.  

And so at the bottom of all of this is the technology of the hardware, there’s the technology of the communications stuff between it, networking, and on the hardware side what has happened a lot is the multi-cores.  You get concurrent programming both from the physical distribution and for the... what’s under the chip themselves.  And this is interesting to me because my PhD topic was distribution and concurrency and such.  So I’ve been looking at that.  So that’s interesting.  

And a lot of the most interesting applications these days fall into that category. Take our cell phones: the last time I looked there are several processes.  Take a single... take an SLR camera, it’s got five or six processors in it and the cobble in the lenses, I mean, that's some interesting code there.  And so whether you think of that as technology or gadgets.  I think of them as a gadget.  I mean a cell phone or a new jetliner, they’re gadgets.  They are things you program and there’s programs in it, there’s techniques, lots of computers.  

What I haven’t talked about much about, and what I don’t think that much about is sort of the web kind of thing and the web business.  From my perspective, that’s somebody else’s business except when the scale becomes really huge.  So you have things like the Google search engines with C++ and I get interested, they get interested.  Facebook has recently turned to C++ because they needed the performance.  I guess in some way of saying here’s my contribution to dealing with global warming because if you can double the efficiency of those systems, you don’t need yet another server farm that uses as much energy as a small town.  

So my view is that there's software and there’s computers in just about everything and if you look at interesting things, well, you find it.


    Question: What is your work setup like?

    Bjarne Stroustrup: I travel with a little laptop, the smallest real computer I can get.  So the 12-and-something screen and... but a decent processor speed.  And where I am, I plug it into a dock and I use two screens and such and then I network to any other resources I want.  If at all possible, I would like to make that machine smaller, but... or at least lighter.  Larger and lighter would be nice, but I don’t get it and too light if you’re stuck in a sardine-class seat on a plane, you still should be able to open up and write.  And you can’t do that with one of those bodybuilder’s editions.  So a smaller machine, convenient machine that you can carry with you and plug it into a bigger system network to more resources.  

My laptop is a Windows.  People always ask that.  And they can’t understand why it’s not my Linux.  Well, my Linux happens to sit on my desk and it talks to a traditional Unix through it.  So I use both on a daily basis.  It just happened that it’s easier to carry the Windows books around.



    Question: Do you prefer to work at night or during the day?

    Bjarne Stroustrup: Real thinking, real work goes on fairly early in the day. And then in the evening, no, not really sort of thought work, not creative work.  I can polish stuff.  I’m not a night bird like that.  I like to think when I’m fresh.  


    Question: Do you listen to music while writing code?

    Bjarne Stroustrup:  Quite often, yes.  I have a mixture of stuff on the computer; I just plug in the earphones and listen.  And there’s a mixture, there’s classical, there’s a bit of rock, there’s a bit of country.  It’s quite surprising what I can actually work with and what I can’t because it really does affect it.  There’s music that sort of takes over and you think about the music, rather than the code.  That’s no good.  And then there’s music that you don’t hear... that doesn’t help either.  And well, so well I found something that works, probably just for me, but I like some music.    

    Question: What advice do you have for C++ developers?

    Bjarne Stroustrup: Most people don’t use C++ anywhere near as well as it could be used.  There are still a lot of people that are trying to use it as a glorified C, or as a slightly mutated Java or SmallTalk, and that’s not the right way of using it.  Go back, read one good book and see if you are up to date or if you happen to be stuck in the '80s or '90s.  We can do much better.  And then, next year, C++ OX will arrive, the next generation of C++ and it’ll support some of the modern programming styles that has been proven useful over the last decade or so—significantly better than C++ 98, which was the previous standard.  And so learn a little bit about it, look at what has been done and try to understand why it was done.  Things are just about to get much better.


Why the Programming Language C Is Obsolete 

    Question: What is the difference between C and C++?
    Bjarne Stroustrup:  C has the basic mechanisms for expressing computations.  It has iterations, it has data types, it has functions and that’s it.  It doesn’t get into the game of expressing abstractions.  So if I want a matrix in C, I would have to say, I want an array and then I want a whole bunch of arrays and when I want to get the third element I have to program my way down to the third element of the fourth row or something like that.  

In C++ you can define something, call it a matrix, you define a subscript operator. If you don’t want rectangular matrixes you can get pentadiagonal matrices, triangular matrices that’s the kind of stuff that people... the expert in that field are interested in.  And you build that set of concepts and then you program it directly.  It’s easier to program, it’s easier to debug and sometimes it’s even easier to optimize for performance when you are expressing the notions at the higher level, at the level where an expert in the field operates, rather than trying to have the expert in the field, say the physicist, also be an expert in dealing with the hardware, with the computer.  There are fields still where you have to have a physicist and a computer scientist to get the work done, but we would like to minimize those because the skill sets are not the same.  So you want to lift from the hardware towards the human level.  

    Question: Is C obsolete?

    Bjarne Stroustrup: This is somewhat controversial.  I think it is obsolete.  I think the languages should have been merged into one, so that C would have been a subset of C++ instead of nearly a subset of C++. And then people could have used whatever parts of the C++ tool set they needed.  As it is now, there are still enough incompatibilities that you have to remember which language you’re writing in, and I don’t think that is necessary.  It appears to be a historical necessity, but it is not a technical necessity.  

I’ve argued for compatibility, very strong compatibility, all the time.  I mean, I started working on C++ three doors down from Dennis Ritchie and we were talking every day.  The competition and tension that has been between C and C++ over the decades certainly didn’t come from home.  

Dennis Ritchie wrote that first book that Brian Carnahan, now I’ll have dinner with Brian next week.  We’re still very good friends as we’ve always been, but sometimes the programmers of the languages don’t quite see it that way.  It should have been one language.


== 2012.1 Interview for IEEE Computer
    Software Development for Infrastructure

== 2012.9 A Concept Design for C++
https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/A-Concept-Design-for-C-


C++ does not provide facilities for directly expressing what a function template requires of its set of parameters. This is a problem that manifests itself as poor error messages, obscure bugs, lack of proper overloading, poor specification of interfaces, and maintenance problems.

Many have tried to remedy this (in many languages) by adding sets of requirements, commonly known as "concepts." Many of these efforts, notably the C++0x concept design, have run into trouble by focusing on the design of language features.

This talk presents the results of an effort to first focus on the design of concepts and their use; Only secondarily, we look at the design of language features to support the resulting concepts. We describe the problem, our approach to a solution, give examples of concepts for the STL algorithms and containers, and finally show an initial design of language features. We also show how we use a library implementation to test our design.

So far, this effort has involved more than a dozen people, including the father of the STL, Alex Stepanov, but we still consider it research in progress rather than a final design. This design has far fewer concepts than the C++0x design and far simpler language support. The design is mathematically well founded and contains extensive semantic specifications (axioms).


== 2012.9 C++11 Style - A Touch of Class
http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style

We know how to write bad code: litter our programs with casts, macros, pointers, naked new and deletes, and complicated control structures. Alternatively (or additionally), we could obscure every design decision in a mess of deeply nested abstractions using the latest object-oriented programming and generic programming tricks. Then, for good measure, we might complicate our algorithms with interesting special cases. Such code is incomprehensible, unmaintainable, usually inefficient, and not uncommon.

But how do we write good code? What principles, techniques, and idioms can we exploit to make it easier to produce quality code? In this presentation, I make an argument for type-rich interfaces, compact data structures, integrated resource management and error handling, and highly-structured algorithmic code. I illustrate my ideas and guidelines with a few idiomatic code examples.

I use C++11 freely. Examples include auto, general constant expressions, uniform initialization, type aliases, type safe threading, and user-defined literals. C++11 features are only just starting to appear in production compilers, so some of my suggestions are conjecture. Developing a "modern style," however, is essential if we don't want to maintain newly-written 1970s and 1980s style code in 2020.

This presentation reflects my thoughts on what "Modern C++" should mean in the 2010s: a language for programming based on light-weight abstraction with direct and efficient mapping to hardware, suitable for infrastructure code.



==2013.7 The Essence of C++
        with examples in C++84, C++98, C++11, and C++14 Past, Present, and Future
http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup


C++11 is being deployed and the shape of C++14 is becoming clear. This talk examines the foundations of C++. What is essential? What sets C++ apart from other languages? How do new and old features support (or distract from) design and programming relying on this essence?

I focus on the abstraction mechanisms (as opposed to the mapping to the machine): Classes and templates. Fundamentally, if you understand vector, you understand C++.

Type safety and resource safety are key design aims for a program. These aims must be met without limiting the range of applications and without imposing significant run-time or space overheads. I address issues of resource management (garbage collection is not an ideal answer and pointers should not be used as resource handles), generic programming (we must make it simpler and safer), compile-time computation (how and when?), and type safety (casts belongs in the lowest-level hardware interface). I will touch upon move semantics, exceptions, concepts, type aliases, and more. My aim is not so much to present novel features and technique, but to explore how C++’s feature set supports a new and more effective design and programming style. 


== 2014.5 What -- if anthing -- have we learned from C++?
http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote


What is the essence of C++? Why did it succeed despite its well-understood flaws? What lessons - if any - can be applied to newer languages?

Themes: Social and technical factors. Resource management. Generic programming. The importance of being inefficient. The importance of syntax. How (not) to specify a language. Standardization and compatibility. And no, I don't plan to condemn C++ - it is still the best language around for a lot of things, and getting better. It just isn't anywhere near perfect (even of its kind) or the best at everything - and was never claimed to be.



== 2014.9 CppCon2014: Make Simple Tasks Simple!
https://channel9.msdn.com/events/CPP/C-PP-Con-2014/013-Make-Simple-Tasks-Simple


Alexander Stepnov

http://www.cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at:https://github.com/CppCon/CppCon2014
--
C++ faces two challenges: Helping programmers address the most demanding tasks in terms of performance, scale, and dependability. It must also help programmers be productive writing ordinary maintainable code. There is much more "ordinary code" than there is performance-critical code. Thus, C++ must make simple tasks simple while not getting in the way of tuning software for the last byte and last cycle where that's necessary. This talk focuses on what C++11 and C++14 offers to simplify programming: auto, range-for loops, move semantics, futures, concepts, and more. However, the focus is not primarily on language features: the key is programming: how can we write better, more readable, efficient, and more maintainable code? If you think that the essence of C++ is clever pointer manipulation and huge class hierarchies you may be in for a few surprises.
--



== 2015.2 Oral History of Bjarne Stroustrup
Interviewed by Paul McJones, on 2015-02-05 in New York, New York, X7399.2015

Bjarne Stroustrup (born 30 December 1950) is a computer scientist who designed and evolved the C++ programming language, from an individual research project in the late 1970s, continuing to the present day as the internationally-standardized language that is ubiquitous in performance-critical systems and applications. The interview covers his youth, his education at the Aarhus University and the University of Cambridge, and his career at AT&T Bell Laboratories, Texas A&M University, and Morgan Stanley. It also covers his early experience with a variety of programming languages including Simula and BCPL. Finally, it focuses on his work on C++ and its predecessor C with Classes, including his goal of combining good abstraction mechanisms with direct access to the hardware. Specific language features discussed include value semantics, templates, concepts, the Standard Template Library, and highlights of the C++11 and C++14 standards.


== 2015.9 CppCon2015: Writing good C++14
https://channel9.msdn.com/Events/CPP/CppCon-2015/Writing-Good-C-14


Presentation Slides, PDFs, Source Code and other presenter materials are available at:https://github.com/isocpp/CppCoreGuid...

How do we use C++14 to make our code better, rather than just different? How do we do so on a grand scale, rather than just for exceptional programmers? We need guidelines to help us progress from older styles, such as "C with Classes", C, "pure OO", etc. We need articulated rules to save us from each having to discover them for ourselves. Ideally, they should be machine-checkable, yet adjustable to serve specific needs.

In this talk, I describe a style of guidelines that can be deployed to help most C++ programmers. There could not be a single complete set of rules for everybody, but we are developing a set of rules for most C++ use. This core can be augmented with rules for specific application domains such as embedded systems and systems with stringent security requirements. The rules are prescriptive rather than merely sets of prohibitions, and about much more than code layout. I describe what the rules currently cover (e.g., interfaces, functions, resource management, and pointers). I describe tools and a few simple classes that can be used to support the guidelines.

The core guidelines and a guideline support library reference implementation will be open source projects freely available on all major platforms (initially, GCC, Clang, and Microsoft).




== 2016.5  Type and Resource-safe C++
A talk by my colleague Abel Sinkovic on debugging metaprograms followed by one by me on type- and resource-safe C++. Abel's talk should be compulsory watching for people who claim that we don't urgently need concepts. May 2016. 



== 2016.7 Simula Discussion led by Richard E. Nance with Birger M�ller-Pederson, Bjarne Stroustrup, and Ole Lehrmann Madsen.


rger Møller-Pedersen, Ph.D.

Birger Møller-Pedersen is a professor in the Department of Informatics, University of Oslo. His academic studies began at the University of Copenhagen, followed by graduate work at Aarhus University, Denmark. In 1977 he joined Kristen Nygaard at the Norwegian Computing Center (NR) to develop the BETA language, based both on DELTA (a system description language based upon the experiences with SIMULA) and SIMULA. He held the position of Senior Research Scientist at Telenor (1995-97) and Principal Scientist with Ericsson (1997-2004), prior to joining the University of Oslo. Møller-Pedersen has served on several program committees for the Object-Oriented Programming Systems Languages & Applications (OOPSLA) conference and the European Conference on Object-Oriented Programming (ECOOP).

Birger Møller-Pedersen is recognized internationally for his accomplishments in, and contributions to, object-oriented languages. He has authored numerous papers and monographs on the subject since his early experience at NR as a member of the team producing the second generation SIMULA implementation. With Kristen Nygaard and Ole Lehrmann Madsen, he authored Object-Oriented Programming in the BETA Programming Language, Addison Wesley 1993. The details of the BETA language project are given in B.B. Kristensen, O.L. Madsen, B. Møller-Pedersen, The when, why and why not of the BETA programming language, Third ACM SIGPLAN conference on History of Programming Languages (HOPL III), 2007. Using SIMULA and BETA concepts and ideas, he was a key contributor to the object-oriented extensions of the ITU Specification and Description Language (SDL). He is a co-author of Systems Engineering Using SDL-92, North-Holland 1994. While with Ericsson he was contributing to UML 2 within OMG.
Ole Lehrmann Madsen, Ph.D.

Ole Lehrmann Madsen is a professor of Computer Science, Aarhus University, and CEO of the Alexandria Institute Ltd, whose mission is to help companies developing new, innovative products and services using information and computing technology. He holds a Master’s and a Ph.D. degree in computer science from Aarhus University. Prior to joining Aarhus, he was a research associate at the Center for Study of Language in Information (CSLI), Stanford University (1984-85) and senior research associate at Sun Microsystems Laboratories in Mountain View, California (1994-95).

Madsen is internationally known for his research publications in object-oriented software systems, including programming and modeling languages and software development environments. He was a major developer of BETA (together with Bent Bruun Kristensen, Birger Møller-Pedersen and Kristen Nygaard) and the Mjølner BETA software development environment. He is a co-founder and chairman of the board for Mjølner Informatics Ltd, which is based on BETA and the Mjølner project. He worked closely with Kristen Nygaard, who was a visiting professor at Aarhus University in 1972-75 and until his death in 2002. He is co-author of Object-Oriented Programming in the BETA Programming Language, Addison Wesley 1993. He has contributed to the creation and adoption of research and innovation policies as a member of various councils, including the Danish Council for Strategic Research and the IT Council of the Central Denmark Region. He is currently Vice-chair of the Directory General CONNECT Advisory Forum: an advisory board for the EU Commission in relation to ICT research and innovation within Horizon 2020, and Chair of The Danish Academy of Technical Sciences’ Council of Digital Wise Men.
Bjarne Stroustrup, Ph.D.

Bjarne Stroustrup is the designer and original implementer of the programming language C++. The popularity and extensive use of C++ stems from its provision of abstraction techniques in an efficient, manageable form for general applications. Stroustrup acknowledges SIMULA as the conceptual roots of C++, noting that he learned object-oriented programming and design from Kristen Nygaard while earning a Master’s in Mathematics from Aarhus University (1975). Moreover, he used SIMULA in the research leading to his Ph.D. from Cambridge University (1979), where he is a member of Churchill College.

Stroustrup is the author of The C++ Programming Language (Fourth Ed.), Addison-Wesley 2013, which is the most widely read book on the subject. He is the author of several books on C++ and programming, targeted at different segments of the programming community. A Managing Director in the technology division of Morgan Stanley in New York City, he is also a visiting professor at Columbia University. Stroustrup headed the Large-scale Programming Research Department of AT&T Bell Laboratories from its creation until 2002. His performance as a professor in the Computer Science and Engineering Department of Texas A&M University led to his elevation to University Distinguished Research Professor in 2014. Among his numerous awards and distinctions are the ACM Grace Murray Hopper Award and the AITO Dahl-Nygaard Senior Prize. He is a member of the U.S. National Academy of Engineering, and an IEEE, ACM, and CHM Fellow. His research interests include distributed systems, design, programming techniques, software development tools, and programming languages. He is actively involved in the ISO standardization of C++.

    Oral History of Bjarne Stroustrup. For the Computer History Museum 2 hours. with transcript. September 2015.
        http://www.computerhistory.org/collections/catalog/102740024
            The Driving Force Behind C++" An 18-minute TEDx talk in Shanghai. October 2016.

== 2016.9 CppCon2016: The Evolution of C++ Past, Present, and Future


== 2016.9 What C++ is and what it will become.
    


== 2016.10 The Driving Force Behind C++


== 2016.11 What C++ is and what it will become
    

== 2016.11 Secret Lightning Talks - Meeting C++. Berlin:
            What makes a concept a good concept ?
    
    Okay so I have a fairly straight talk here and just going to talk fast
to make it lightning. We talked alot about concept should look like and I'll
say a little bit about that but mostly I'll talk about what makes a nice 
concept what are the concepts we want and I'll give credit there's Alex 
Stepanov who has pushed for four concepts for a very long time like 20
years that's the other three me Andres Aden and Gabi does raise sort of the
maintain designers of the current cart of this and andrew is the implementer
or in TCC to C&G 6.2.

-- PPT 1
    Wanted in 1987 (and now):
    - Full generality/expressiveness
    - Zero overhead compared to hand coding
    - Well-specified interfaces
    We now have
    - Turing completeness
    - Better than hand-coding performance
    - Lousy interfaces (basically compile-time duck typing)
    Efforts
    - Texas + Indiana => C++0x concepts (failed)
    - Palo Alto meeting (AS, BS, AS, more)
    - "Concepts are predicates" design (BS, GDR, AS)
    - Concepts TS +GCC implementation + Ranges Ts and implementation
    Design Principes:
    - Provide good inteface
    - Zero-overhead
    - generality

Okay here we wanted concept in ages 87 could't get all of it. There's been
Several efforts over the years. The C++ x1 sort of collapsed and then we
did an interesting thing.
    Alex Stepanov called all the main people that he could get, so Palo Alto
and said okay we are not going to the same concept we"re going to use them.
We're going to write the concepts for the algorithms in the STL. We're going
 to write all that down and then your job pointing at me is to go home and
design the languages to make this work and so we started with application 
and the first thing we did was to write a hundred page specifation of the 
library which sort of has evoled into parts of the Rages 1 and this is what
I'm going through to talk to you about.


        
-- PPT 2 Generic Programming is "just" Programming
    - Traditional code
        
        double sqrt(double d);  //C++84: accept any d that is a double
        double d = 7;
        double d2 = sqrt(d);    // fine: d is a double

        vector<string> vs = {"Good", "old", "templates"};
        double d3 = sqrt(vs);   // error: vs is not double

    - 1990s style generic code
        
        template<class T> void sort(T& c)   //C++98: accept a c of any type T
        {
            //code for sorting(depending on various properties of T,
            //such as having [] and a value type with <
        }

        vector<string> vs = {"Good", "old", "templates"};
        sort(vs);       //fine: vs happens to have
                        //all the syntactic properties required by sort

        doubled d = 7;
        sort(d);        //error: d doesn't have a [] operator
    - Generic code using a concept (Sortable)
        
        void sort(Sortable& c); //Concepts: accept andy c that is a Sortable container

        vector<string> vs= {"Hello", "new", "World" };
        sort(vs);   //fine: vs is a Sortable container

        double d = 7;
        sort(d);    //error: d is not a Sortable container
                    // (double does not provide [], begin(), etc.)

Here's what I showed you yesterday good old code, standard template code without
concepts with horrible different and some interesting side effects like these 
splendid unmatched error, messages and finally that we can today to just as well
in generic sense that is we can define so audible. We don't have to have Danish
to define double for us

-- PPT 3 Concepts are compile-time predicates
    - A concept is a predicate on one or more arguments
    - Examples
        i. an iterator: Iterator<T> // is T an iterator?
        i. a random access iterator: Random_access_iterator<T> //is T a RAI;
        i. a number: Number<T> // is T a Number?
        i. Mergeable sequences: Mergeable<In1, In2, Out>
    - Template declaretion (long, very explicit form)
        template<typename S, typename T)
            requires Sequence<S> && Equlity_comparable<Value_type><S>
        Iterator_of<S> find(S& seq, const T& value);
    - Notes: a cencept can take several type arguments

    - A concept is a predicate on one or more arguments
        
        void use(vector<string>& vs, list<double>& lstd)
        {
            auto p0 = find(vs, "Waldo");    //OK
            auto p1 = find(vs, 0.5772);     //error: can't compare string to double
            auto p2 = find(lstd, 0.5772);   //OK
            auto p3 = find(lstd, "Waldo");  //error: can't compare double to string

            if (p0 != vs.end()) { /* found Waldo */ }
            // ...
        }

and their compile time predicates if you look around there's alot of that around.
I mean iterators are defined as you can ask a type if it's an iterator random
access these raters and such how about a number We can define what a number is 
Muchie poor. Basically, you can just ask a type what it is and its not just one
type combinations of types this is simply sort of logic you can ask for properties
and get on with it and you can take as many paremeters as you like.  And you can 
get it to work so we can try and find in a vector Waldo find finding the vector
Euler's constant and that will not work it is not a string and vice-versa. It all
works very fine.


-- PPT 4 Shorthand Notations
    // the template argument must be a type, and
    // that type must be a sequence, and
    // s must be a reference to that type
template<typename Seq>
        requries Sequence<Seq>
void algo(Seq& s);

    // the template argument must be a sequence, and
    // s must be a reference to that sequence
template<Sequence Seq>
void algo(Seq& s);

    // s must be a reference to a sequence
void algo(Sequence& s);

    - Design principles:
        i. Onion principle
        i. Keep simple things simple
Now we looked at this and we looked at the user use of it in a large code 
base and we found that we start out with a sort of very computer science view 
of this, so if you look at the first version there says that there must be a 
template document that's a type and that type must be a sequence and it must
take a reference the type that had to be a sequence. 
    We don't speak like that so we had a shorter form which says we want a type
that's a sequence and the argument must be a reference to that sequence.
    And finally we got to what we actually say is that the arguments must be a 
sequence. So that simplifies a lot. I put some desing principle in here "simple
things are now simple". The  onion principle is that you can do things very 
simply but you can't do everything, so you peel one layer off the onion and you
still can't do everything, so you peel another layer off the onion and you cry 
more and more as you get closer. This not the only place you do this in C++.


-- PPT 5 Defining concepts
    - Concepts are compile-time predicates
        i. First choice: use a library of concepts
        i. If the right one isn't there: define your own
        
        template<typename T>    //Build from other concepts
        concept bool Sortable = 
            Sequence<T> &&
            Random_access<T> &&
            Comparable<Value_type<T>>;

        template<typename T>    //Build from primitive requirements
        concept bool Equality_comparable =
            requires(T a, T b) {
                    { a == b } -> bool; // compare Ts with == return bool
                    { a != b } -> bool; // compare Ts with != return bool


So, How do you define concepts now we're leaving what i did yestoday.
Basically, the idea is you picked them from somebody else's library just
like functions and other classes and such, but basically you can say combine
yourself a new concept by simply saying I want an expression so audible it
should a sequence and a random access and the comp we have to be able compare
value types and so that's the next level of complexity. 
    And finally you get down to the crying here again we can define it ourselves
out of properties so here we say that to be equally comparable we have to 
take two varables of the type and we have to be able to do assginment and it 
should heat deal the pool or and it's not assignment equality and inequality 
and utility yield a bool so it's fairly easy to build up concepts and you 
will find that the text for writing the concepts is shorter than the text
for defining them in the standard we also had something for concepts but for
semantics but we don't have yet in the language.

-- PPT 6 What makes a concept good?
    - Represent a fundamental concept of a domain
        i. C/C++ build-in type concepts: arithmetic and floating 
            ii. (yes, C has concepts!)
        i. STL concepts like iterators and containers
        i. Mathematical concepts like monad, group, ring, and field
        i. Graph concepts like edges and vertices; graph, DAG, etc.
    - Has semantics
        i. E.G., for Number, +, -, *, and / must obey the usual mathematical
            rules
        i. E.G., 
            template<typename T>    // suspicious: no sematics
            concept bool Incrementable = requires(T a, int b) {{ a += b}->T&;


So now to the real question what does a can't make a concept good I mean we 
don't just write functions and discuss functions we discuss about what they
do one how you desing them well, so that's the level we have so before we can
understand how al this works. We have the building types of concepts there's
arithmetic types and floating types so We've actually had concepts in C and 
C++ since about 74 STL concepts they're iterator and containers you can look
up what they are. They're specified. It's just as I keep pointing out compiler
store great manuals and other fields have concepts Monett group ring and field
and graphical concepts and the other thing we observe is that in all of these
cases and all of the case where we have what we'll consider a good concept it 
has some sematics I Mean it's not just plus/minus supply and divide they have 
to have some relation to each other. And you should be very suspicious when
somebody comes and says I've got a concept but it doesn't have any sematics.
That's probably not a concept it's a misuse of the language. Bit bit like a 
function I have a function but I can't tell you what it does.

-- PPT 7 What makes a concept good?
    - Specifying semantics is a very effective design technique
        i. Helps find logical errors
        i. Write out axioms (1st order predicate logic)
            ii. Lots of examples in the Palo Alto TM
    - Incomplete concepts("constraints")
        i. Can be useful for initial development
        i. As building blocks for real concepts

So one of the thing that we found as a practical thing is specifying semantics
is a very effective design technique. You start writing a concept some
constraints on an algorithms and you find that the first version doesn't 
work too well and the second version doesn't work too well. It's like any
other code but saying okay. Let's try and think about the semantics let's try 
and write the semantics down. You can look in the Palo Alto report which
was the report from the meeting in Palo Alto that Alex Stephan of have us 
design the whole thing has the algorithmic the semantics of everything defined.
I don't have time for an example here. Incomplete concepts constraints can be 
used for initial development but shouldn't really be happy till you reach
something with semantics that you can let your users use.

-- PPT 8 Try for complete concepts 
    - Related operations and types
        template<typename T>
        concept bool Sequence = 
            requires(T t) {
                typename Value_type<T>;     // must have a value type
                typename Iterator_of<T>;    // must have an iterator type

                { begin(t) } -> Iterator_of<T>; // must have begin() and end()
                { end(t) } -> Iterator_of<T>;

                requires Input_iterator<Iterator_of<T>>;
                retuires Same_type<Value_Type<T>,Value_type<Iterator_of<T>>;
            };
        
So you try for complete concepts here's the sequence a sequence has to have
a value type and an itertor type that's the first two lines it has to have 
a beginning and end, and the beginning the end each has to generate and 
iterator, and then there's some requirements on the iterator. The iterator
has to be an input iterator and this should be the same type of the value
type of key and the value type of the iterator T's should be done this is 
not quite complete but it's pretty complete and you can fill it up 
yourself from the standard.


-- PPT 9 Ideal:"plug and play"
    - Express requirements for algorithms in terms of fundamental and 
      complete concepts
        i. Not "specify the minimal requirements for an algorithm"
    - For example
        template<Forwar_iterator Iter, typename Val> // Incrementable or Number? Number!
        Val sum(Iter first, Iter last, Val acc)
        {
            while (first != last) {
                acc += *first;  // +=  or  + and = ?
                ++first;
            }
            return acc;
        }
        
    - Design principe:
        i. An implementation isn't a specification
        i. Look for sematic coherence(一致性)

The Ideal here's plug and play. A lot of us ha gotten used to the habit of 
providing absolute minimal specifications for generic code. So a lot of 
people would look at that simplified sum and saying that it requires something 
to be incremental because the accumulator is incremented and that leads to
really complicated design, really complicated systems.  What you really should
do is to say no no, we take a number that will give the implement of the 
freedom of choosing between plus and plus equals for doing the thing. 
And the design principle is not minimal specification it is active int 
sematic coherence. You have to look at what is the semantics of what you are
doing.
    And implementation is not the specification.
    And implementation is one example of an implementation.
And for most interesting cases, next year the year after, somebody comes around
with a cleverer, one than the one you thought of. And if you have minimal minimal
mised the requirements, minimize the the some kind of minimal constant there.
You can't fix your code without changing all the interfaces.


-- PPT 10 Accidental match?
    - We do not need or have "modeling declarations"
        i. A type matches a concept if it provides the required properties
    - Consider a classic bad example
        template<typename T>        // suspicious: single property concept
        concept bool Drawable = requires(T t) { t.draw(); };

        class Shpe { /* ... */ void draw(); /* light up selected pixels on the screen */ };

        class Cowboy { /* ... */ void draw(); /* pull deadly weapon from holster */ };

        template<Drawable D>
        void draw_all(vector<D*>& v)    // ye olde draw all shapes example
        {
            for (auto& x : v) v->draw();
        }


So one thing that people talk about a lot is accidental match and I found in
my mailbox a very old example namely the shape and the cowboy from the dark
ages of object-oriented programming. Now done with concepts you have a drawable
concept and you have a class shape with a drawn a class cowboy the draw. And
well something happens we don't quite know why well I told you to just be 
suspicious about concepts without sematics, and if you have to specify the 
sematics of draw
    1. it's hard to specify message to the one operation and 
    2. you wouldn't make it that mistake 
So what you do is a real concept since I'm more than one operation and 
more thant one associated type, and that means that basically this nice 
theoretical problem mostly goes away.


-- PPT 11 Real concepts rarely accidentally match
    - But a few do 
        i. Classical example: Input_iterator and Forward_iterator
    - If they do
        i. Add an operator to allow disambiguation
        i. Use a traits class (as currently)
    - Beware of single property "concepts"
        i. Addable, subtractable, incrementable, ... (the "dreaded *able"s)
    - Design principles:
        i. Don't let the tail wag the dog
        i. Keep simple thing simple
        
There's a classical example of things that look exactly the same from a syntactic
point of view but not from a sematic point of view.  And we talk a lot about
that the classic example is input iterator and forward iterator if they're 
under your control, just add an operation random operation fro anything to 
distinguish them. If not you can use traits classes exactly what you do today.
Concepts do not take away your you show abilities and so there's some beware 
of some single property concepts and design principle here. Don't let the tail
wat the dog because if you design to avoid incidental crashed you can end up
with something that makes all of your code uglier.


-- PPT 12 Try concepts! You'll never go back
    - Concepts help us develop better designs
        i. Improve interoperability ("plug and play")
        i. Help focus on fundamental issues and semantics
    - Concepts provide better specification of interfaces
    - Concepts simplify code
        i. Far, far fewer enabe_ifs
        i. Simpler and more precise expression of ideas ("shorter code")
    - Concepts give precise and early error messages
        i. And fewer errors

    - Desing principles:
        i. Provide good interfaces
        i. Look for sematic coherence
        i. Don't force the user to do what a machine does.
        i. Keep simple things simple

Overloading I showed you that yesterday basically go try the concepts. They
are seriously addictive if you're right, template code they shortened your
template code dramatically. It limits the amount of boilerplate and basically
the idea is that it's better code -- shorter cleaner, nicer code. And it removes
boilerplate. Notice that the last thing down there is the elimination of thost
horrible error messages. The horrible error messages is a symptom it's not the 
disease what you do is you fix your design, you fix your interfaces and then 
the code gets better. 
    Thank you!

    
== 2017.9 CppCon2017: Learning and Teaching Modern C++

== 2017.12 The Continuing Evolution of C++

on the evolution for C++ from the earliest days until 2020.

Stroustrup discusses the development and evolution of the C++, one of the most widely used programming languages ever.

The development of C++ started in 1979. Since then, it has grown to be one of the most widely used programming languages ever, with an emphasis on demanding industrial uses. It was released commercially in 1985 and evolved through one informal standard (“the ARM”) and several ISO standards: C++98, C++11, C++14, and C++17. How could an underfinanced language without a corporate owner succeed like that? What are the key ideas and design principles? How did the original ideas survive almost 40 years of development and 30 years of attention from a 100+ member standards committee? What is the current state of C++ and what is likely to happen over the next few years? What are the problems we are trying to address through language evolution?




